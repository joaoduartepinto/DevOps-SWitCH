# Ca2 - Part 2 - Tut-Basic-Gradle

## 1. Set-Up

To start exploring Gradle we need to do some setup.

### 1.1. Start new Gradle spring project

First, we need to create a new Spring Boot project.

Go to https://start.spring.io and create the new gradle spring project with the following dependencies:
- Rest Repositories
- Thymeleaf;
- JPA;
- H2.

Like:

![new-spring-gradle](./assets/new-spring-gradle.png)

Click in generate and a zip file will be downloaded.

Unzip the file in the desired folder.

### 1.2. Changes in Src folder

Now we are going to replace the src folder of this new project with the tut-basic src folder made in Ca1. The webpack.config.js and package.json files must also be copied and copied at the root of the new project.

The folder src/main/resources/static/built/ must also be deleted, as it contains compiled files.

### 1.3. Add frontend plugin

If we now run the application, the web page in localhost: 8080 is empty, we have to install the plugin for the gradle to handle the frontend.

Command to run app, must be used in a terminal inside root of project:
```
$ ./gradlew bootRun
```

It is then necessary to add the plugin *org.siouan.frontend* to the build.gradle file.

```
plugins {
    id 'org.springframework.boot' version '2.4.4'
    id 'io.spring.dependency-management' version '1.0.11.RELEASE'
    id 'java'
    // Added to run fronted
    id "org.siouan.frontend" version "1.4.1"
}
```

It is also necessary to configure the plugin by placing the following code also in the *build.gradle* file:

```
frontend {
    nodeVersion = "12.13.1"
    assembleScript = "run webpack"
}
```

Last, but not least, we have to add the webpack to the scripts section of *package.json* to configure the webpack execution:

```
  "scripts": {
    "watch": "webpack --watch -d",
    // Add the next line
    "webpack": "webpack"
  },
```

### 1.4. Build

Now, let's build the project for the files related to the frontend to be compiled:

```
$ ./gradlew build
```

### 1.5. BootRun

To run the application we must use the following command:

```
$ ./gradlew bootRun
```

We must then also access the address *localhost:8080* from a browser to see what already appeared at the end of Ca1.

## 2. Add tasks

Tasks are added to the build.gradle file.

### 2.1. Add a task to copy the generated jar to a folder named "dist"

To create a task of type Copy, the type must be declared:

```
task <name_of_task> (type: Copy) {

}
```

So let's create a task that copies the jar file, created after build, to a "dist" folder, for that, within the task, the "from", "include" and the "into" must be declared:

```
task copyJar(type: Copy) {
    from 'build/libs'
    include '*.jar'
    into './dist/'
}
```


### 2.2. Add a task to delete all the files generated by webpack

To create a task of type Delete, the type must be declared:

```
task <name_of_task> (type: Delete) {

}
```

So let's create a task that deletes the files generated by webpack (path from root: src/main/resources/static/built/):

```
task deleteWebpackFiles(type: Delete) {
    delete './src/main/resources/static/built/'
}
```

This task should be run automatically by the gradle before running the **clean** task, so we must add the following to build.gradle:

```
clean {
    dependsOn deleteWebpackFiles
}
```

## 3. Experiment all the developed features

Let's explore the tasks previously added.

### 3.1. Execute task copyJar

To execute the copyJar task run the following command:

```
$ ./gradlew copyJar
```

After executing the command, a new directory called "dist" was created at the root of the project and inside it will be the .jar file.

### 3.2. Execute task deleteWebpackFiles

To execute the deleteWebpackFiles task run the following command:

```
$ ./gradlew deleteWebpackFiles
```

After executing the command, the /src/main/resources/static/built/ folder have been deleted.

### 3.3. Execute task clean

To check if the deleteWebpackFiles task is executed before the **clean** task, we have to create the files and directory again, running the build command again.

To execute the clean task run the following command:

```
$ ./gradlew clean
```

After executing the command, the /src/main/resources/static/built/ folder have been deleted.

### 3.4. Call tests when build

During the builds it was noticed that the existing tests in the project were not invoked, so the following sourceSet was added to the build.gradle file, for the tests to be executed during the build:

```
sourceSets {
    main {
        java {
            srcDirs = ['src/main/java']
        }
    }

    test {
        java {
            srcDirs = ['src/tests/main']
        }
    }
}
```

To check and see that the tests are run during the build we execute the following command:

```
$ ./gradlew build --scan
```

Following the link and the result must be:

![build-scan](./assets/build-scan.png)

## 4. Alternative - Maven

After trying other alternatives, like bazel, sbt and ant, and having failed in all of them, I decided to choose **maven** as an alternative.

The implementation failures of the alternatives were due to the difficulty of configuring the necessary dependencies for the project, always leading to failed builds.

In turn, as maven is a widely used tool in the market (for example, bazel makes use of the Maven repository to add dependencies), using this alternative may prove to be an acquisition of skills that may be needed in the future.

### 4.1. Analysis

In this section we will do the analysis between maven and gradle.

#### 4.1.1. Before Maven - Ant

Before we start talking about Maven we have to start by talking about its predecessor, Ant, which was launched in 2000, in order to automate the build processes. Ant alone does not do dependency management and has to be used in conjunction with Ivy. One of the Ant capabilities is that it allows the creation of tasks, which are called targets.

#### 4.1.2. Maven

To allow the management of dependencies in a single file (pom.xml), Maven was born in 2005. It also allows the use of plugins for the execution of specific tasks in the build process.

The use of a single configuration file makes it easier to manage dependencies, but, as it is an XML file, the same extension problems can happen as in Ant.

Maven uses a build pattern, which are the phases of the build cycle. With the use of plugins it is allowed to make an adaptation in the execution of tasks. A problem can arise when there is a project with its own characteristics and that there are no plugins to accomplish what you want ... Maven allows you to create customs plugins, but it can be a complex process.

#### 4.1.3. Gradle

In a nutshell, Gradle brings together the good in Maven and Ant.

Gradle manages dependencies and automates the build process, just like Maven, but allows the use of Maven, Ivy and private repositories.

The tool has the features of Maven and the flexibility of Ant, suggesting itself as an evolution in the build tools.

Gradle uses DSL in Groovy to create the configuration file, called build.gradle, which allows you to program the configuration and schedule custom tasks to perform automated tasks, as performed in the first part of this tutorial.

#### 4.1.4. Resume of diferences

>"Gradle is not a rival to Maven, in fact he came to improve what already existed!"

- Maven:
    - Uses XML;
    - Convention over configuration;
    - Configuration file: pom.xml;
    - Plugin based;
    - Compound and fixed build cycle and standard goals.
    
- Gradle:
    - Uses DLS based in Groovy;
    - Uses conventions but allows flexibility;
    - Configuration file: build.gradle;
    - Uses plugins;
    - It uses the concept of tasks, containing built-in taks and allows the creation of new classes, it also allows to customize the build process;
    - Highly configurable!

### 4.2. Implementation

So let's walk through the implementation of the alternative.

#### 4.2.1. Setup

As we did in the first part, we created an empty maven project, replacing the src folder and copying the files webpack.config.js and package.json.

#### 4.2.2. pom.xml

pom.xml at this moment

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
		 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.2.4.RELEASE</version>
		<relativePath/>
	</parent>

	<groupId>com.devops</groupId>
	<artifactId>tut-basic-maven</artifactId>
	<version>0.0.1-SNAPSHOT</version>

	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<java.version>1.8</java.version>
	</properties>

</project>
```

#### 4.2.3. Add necessary dependencies and plugins

Below the properties, we must place the necessary dependencies and plugins within the build:

```
[...]
<dependencies>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-rest</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
        </dependency>
        
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        
    </dependencies>

    <build>
    
        <plugins>
    
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>

            <plugin>
                <groupId>com.github.eirslett</groupId>
                <artifactId>frontend-maven-plugin</artifactId>
                <version>1.6</version>
                <configuration>
                    <installDirectory>target</installDirectory>
                </configuration>
                <executions>
                    <execution>
                        <id>install node and npm</id>
                        <goals>
                            <goal>install-node-and-npm</goal>
                        </goals>
                        <configuration>
                            <nodeVersion>v10.11.0</nodeVersion>
                            <npmVersion>6.4.1</npmVersion>
                        </configuration>
                    </execution>
                    <execution>
                        <id>npm install</id>
                        <goals>
                            <goal>npm</goal>
                        </goals>
                        <configuration>
                            <arguments>install</arguments>
                        </configuration>
                    </execution>
                    <execution>
                        <id>webpack build</id>
                        <goals>
                            <goal>webpack</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                </configuration>
            </plugin>

        </plugins>

    </build>

[...]
```

#### 4.2.4. Custom tasks (using Ant tasks)

For the usual copy and delete tasks we will use the tasks available in the ant. We then need to create a build.xml file:

```
<project name="tut-basic-maven"  basedir=".">

</project>
```

We then add the respective tasks to the build.xml file:

```
[...]

  <target name="deleteWebpackFiles">
        <delete includeEmptyDirs="true">
            <fileset dir="src/main/resources/static/built"/>
        </delete>
    </target>

    <target name="copyJar">
        <copy file="target/tut-basic-maven-0.0.1-SNAPSHOT.jar" todir="dist/"/>
    </target>
    
[...]
```

to run these tasks through maven we have to use the AntRun plugin. In pom.xml, inside the plugins we should put:

```
[...]

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-antrun-plugin</artifactId>
                <version>1.7</version>
                <executions>
                    <execution>
                        <phase>clean</phase>
                        <goals>
                            <goal>run</goal>
                        </goals>
                        <id>deleteWebpackFiles</id>
                        <configuration>
                            <target>
                                <ant antfile="${basedir}/build.xml">
                                    <target name="deleteWebpackFiles"/>
                                </ant>
                            </target>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-antrun-plugin</artifactId>
                <version>1.7</version>
                <executions>
                    <execution>
                        <id>copyJar</id>
                        <configuration>
                            <target>
                                <ant antfile="${basedir}/build.xml">
                                    <target name="copyJar"/>
                                </ant>
                            </target>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            
[...]
```

Note that for the task of deleting files generated by Webpack, the clean phase was placed to be executed when mvn clean.

#### 4.2.5. Explore

To generate the jar file and the files generated by the webpack we can run:

```
$ mvn install
```

#### 4.2.5.1. Execute task copyJar

To execute the copyJar task run the following command:

```
$ mvn antrun:run@copyJar
```

After executing the command, a new directory called "dist" was created at the root of the project and inside it will be the .jar file.

#### 4.2.5.2. Execute task deleteWebpackFiles

To execute the deleteWebpackFiles task run the following command:

```
$ mvn antrun:run@deleteWebpackFiles
```

After executing the command, the /src/main/resources/static/built/ folder have been deleted.

#### 4.2.5.3. Execute task clean

To check if the deleteWebpackFiles task is executed before the **clean** task, we have to create the files and directory again, running the build command again.

To execute the clean task run the following command:

```
$ mvn clean
```

After executing the command, the /src/main/resources/static/built/ folder have been deleted.

## 5. References

[Spring](https://spring.io)
[Gradle](https://gradle.com)
[Maven vs Gradle : quem ganha, afinal?](https://deviniciative.wordpress.com/2019/06/23/maven-vs-gradle-quem-ganha-afinal/)
[Introduction to the Build Lifecycle](https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Lifecycle_Reference)